// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Movie is an object representing the database table.
type Movie struct {
	UUID            null.String `boil:"uuid" json:"uuid,omitempty" toml:"uuid" yaml:"uuid,omitempty"`
	Title           string      `boil:"title" json:"title" toml:"title" yaml:"title"`
	ImdbLink        string      `boil:"imdb_link" json:"imdb_link" toml:"imdb_link" yaml:"imdb_link"`
	Year            int64       `boil:"year" json:"year" toml:"year" yaml:"year"`
	Rated           null.String `boil:"rated" json:"rated,omitempty" toml:"rated" yaml:"rated,omitempty"`
	Released        null.String `boil:"released" json:"released,omitempty" toml:"released" yaml:"released,omitempty"`
	Plot            null.String `boil:"plot" json:"plot,omitempty" toml:"plot" yaml:"plot,omitempty"`
	Country         null.String `boil:"country" json:"country,omitempty" toml:"country" yaml:"country,omitempty"`
	Language        null.String `boil:"language" json:"language,omitempty" toml:"language" yaml:"language,omitempty"`
	BoxOffice       null.String `boil:"box_office" json:"box_office,omitempty" toml:"box_office" yaml:"box_office,omitempty"`
	Production      null.String `boil:"production" json:"production,omitempty" toml:"production" yaml:"production,omitempty"`
	CallFelissa     int64       `boil:"call_felissa" json:"call_felissa" toml:"call_felissa" yaml:"call_felissa"`
	Slasher         int64       `boil:"slasher" json:"slasher" toml:"slasher" yaml:"slasher"`
	Zombies         int64       `boil:"zombies" json:"zombies" toml:"zombies" yaml:"zombies"`
	Beast           int64       `boil:"beast" json:"beast" toml:"beast" yaml:"beast"`
	Godzilla        int64       `boil:"godzilla" json:"godzilla" toml:"godzilla" yaml:"godzilla"`
	CreatedDatetime int64       `boil:"created_datetime" json:"created_datetime" toml:"created_datetime" yaml:"created_datetime"`
	ImdbID          string      `boil:"imdb_id" json:"imdb_id" toml:"imdb_id" yaml:"imdb_id"`
	WallpaperFu     null.Bool   `boil:"wallpaper_fu" json:"wallpaper_fu,omitempty" toml:"wallpaper_fu" yaml:"wallpaper_fu,omitempty"`
	RuntimeMinutes  null.Int64  `boil:"runtime_minutes" json:"runtime_minutes,omitempty" toml:"runtime_minutes" yaml:"runtime_minutes,omitempty"`

	R *movieR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L movieL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var MovieColumns = struct {
	UUID            string
	Title           string
	ImdbLink        string
	Year            string
	Rated           string
	Released        string
	Plot            string
	Country         string
	Language        string
	BoxOffice       string
	Production      string
	CallFelissa     string
	Slasher         string
	Zombies         string
	Beast           string
	Godzilla        string
	CreatedDatetime string
	ImdbID          string
	WallpaperFu     string
	RuntimeMinutes  string
}{
	UUID:            "uuid",
	Title:           "title",
	ImdbLink:        "imdb_link",
	Year:            "year",
	Rated:           "rated",
	Released:        "released",
	Plot:            "plot",
	Country:         "country",
	Language:        "language",
	BoxOffice:       "box_office",
	Production:      "production",
	CallFelissa:     "call_felissa",
	Slasher:         "slasher",
	Zombies:         "zombies",
	Beast:           "beast",
	Godzilla:        "godzilla",
	CreatedDatetime: "created_datetime",
	ImdbID:          "imdb_id",
	WallpaperFu:     "wallpaper_fu",
	RuntimeMinutes:  "runtime_minutes",
}

var MovieTableColumns = struct {
	UUID            string
	Title           string
	ImdbLink        string
	Year            string
	Rated           string
	Released        string
	Plot            string
	Country         string
	Language        string
	BoxOffice       string
	Production      string
	CallFelissa     string
	Slasher         string
	Zombies         string
	Beast           string
	Godzilla        string
	CreatedDatetime string
	ImdbID          string
	WallpaperFu     string
	RuntimeMinutes  string
}{
	UUID:            "movie.uuid",
	Title:           "movie.title",
	ImdbLink:        "movie.imdb_link",
	Year:            "movie.year",
	Rated:           "movie.rated",
	Released:        "movie.released",
	Plot:            "movie.plot",
	Country:         "movie.country",
	Language:        "movie.language",
	BoxOffice:       "movie.box_office",
	Production:      "movie.production",
	CallFelissa:     "movie.call_felissa",
	Slasher:         "movie.slasher",
	Zombies:         "movie.zombies",
	Beast:           "movie.beast",
	Godzilla:        "movie.godzilla",
	CreatedDatetime: "movie.created_datetime",
	ImdbID:          "movie.imdb_id",
	WallpaperFu:     "movie.wallpaper_fu",
	RuntimeMinutes:  "movie.runtime_minutes",
}

// Generated where

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_String) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_String) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Int64 struct{ field string }

func (w whereHelpernull_Int64) EQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int64) NEQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int64) LT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int64) LTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int64) GT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int64) GTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var MovieWhere = struct {
	UUID            whereHelpernull_String
	Title           whereHelperstring
	ImdbLink        whereHelperstring
	Year            whereHelperint64
	Rated           whereHelpernull_String
	Released        whereHelpernull_String
	Plot            whereHelpernull_String
	Country         whereHelpernull_String
	Language        whereHelpernull_String
	BoxOffice       whereHelpernull_String
	Production      whereHelpernull_String
	CallFelissa     whereHelperint64
	Slasher         whereHelperint64
	Zombies         whereHelperint64
	Beast           whereHelperint64
	Godzilla        whereHelperint64
	CreatedDatetime whereHelperint64
	ImdbID          whereHelperstring
	WallpaperFu     whereHelpernull_Bool
	RuntimeMinutes  whereHelpernull_Int64
}{
	UUID:            whereHelpernull_String{field: "\"movie\".\"uuid\""},
	Title:           whereHelperstring{field: "\"movie\".\"title\""},
	ImdbLink:        whereHelperstring{field: "\"movie\".\"imdb_link\""},
	Year:            whereHelperint64{field: "\"movie\".\"year\""},
	Rated:           whereHelpernull_String{field: "\"movie\".\"rated\""},
	Released:        whereHelpernull_String{field: "\"movie\".\"released\""},
	Plot:            whereHelpernull_String{field: "\"movie\".\"plot\""},
	Country:         whereHelpernull_String{field: "\"movie\".\"country\""},
	Language:        whereHelpernull_String{field: "\"movie\".\"language\""},
	BoxOffice:       whereHelpernull_String{field: "\"movie\".\"box_office\""},
	Production:      whereHelpernull_String{field: "\"movie\".\"production\""},
	CallFelissa:     whereHelperint64{field: "\"movie\".\"call_felissa\""},
	Slasher:         whereHelperint64{field: "\"movie\".\"slasher\""},
	Zombies:         whereHelperint64{field: "\"movie\".\"zombies\""},
	Beast:           whereHelperint64{field: "\"movie\".\"beast\""},
	Godzilla:        whereHelperint64{field: "\"movie\".\"godzilla\""},
	CreatedDatetime: whereHelperint64{field: "\"movie\".\"created_datetime\""},
	ImdbID:          whereHelperstring{field: "\"movie\".\"imdb_id\""},
	WallpaperFu:     whereHelpernull_Bool{field: "\"movie\".\"wallpaper_fu\""},
	RuntimeMinutes:  whereHelpernull_Int64{field: "\"movie\".\"runtime_minutes\""},
}

// MovieRels is where relationship names are stored.
var MovieRels = struct {
	MovieActors    string
	MovieDirectors string
	MovieGenres    string
	MovieRatings   string
	MovieWatches   string
	MovieWriters   string
}{
	MovieActors:    "MovieActors",
	MovieDirectors: "MovieDirectors",
	MovieGenres:    "MovieGenres",
	MovieRatings:   "MovieRatings",
	MovieWatches:   "MovieWatches",
	MovieWriters:   "MovieWriters",
}

// movieR is where relationships are stored.
type movieR struct {
	MovieActors    MovieActorSlice    `boil:"MovieActors" json:"MovieActors" toml:"MovieActors" yaml:"MovieActors"`
	MovieDirectors MovieDirectorSlice `boil:"MovieDirectors" json:"MovieDirectors" toml:"MovieDirectors" yaml:"MovieDirectors"`
	MovieGenres    MovieGenreSlice    `boil:"MovieGenres" json:"MovieGenres" toml:"MovieGenres" yaml:"MovieGenres"`
	MovieRatings   MovieRatingSlice   `boil:"MovieRatings" json:"MovieRatings" toml:"MovieRatings" yaml:"MovieRatings"`
	MovieWatches   MovieWatchSlice    `boil:"MovieWatches" json:"MovieWatches" toml:"MovieWatches" yaml:"MovieWatches"`
	MovieWriters   MovieWriterSlice   `boil:"MovieWriters" json:"MovieWriters" toml:"MovieWriters" yaml:"MovieWriters"`
}

// NewStruct creates a new relationship struct
func (*movieR) NewStruct() *movieR {
	return &movieR{}
}

func (r *movieR) GetMovieActors() MovieActorSlice {
	if r == nil {
		return nil
	}
	return r.MovieActors
}

func (r *movieR) GetMovieDirectors() MovieDirectorSlice {
	if r == nil {
		return nil
	}
	return r.MovieDirectors
}

func (r *movieR) GetMovieGenres() MovieGenreSlice {
	if r == nil {
		return nil
	}
	return r.MovieGenres
}

func (r *movieR) GetMovieRatings() MovieRatingSlice {
	if r == nil {
		return nil
	}
	return r.MovieRatings
}

func (r *movieR) GetMovieWatches() MovieWatchSlice {
	if r == nil {
		return nil
	}
	return r.MovieWatches
}

func (r *movieR) GetMovieWriters() MovieWriterSlice {
	if r == nil {
		return nil
	}
	return r.MovieWriters
}

// movieL is where Load methods for each relationship are stored.
type movieL struct{}

var (
	movieAllColumns            = []string{"uuid", "title", "imdb_link", "year", "rated", "released", "plot", "country", "language", "box_office", "production", "call_felissa", "slasher", "zombies", "beast", "godzilla", "created_datetime", "imdb_id", "wallpaper_fu", "runtime_minutes"}
	movieColumnsWithoutDefault = []string{"title", "imdb_link", "year", "call_felissa", "slasher", "zombies", "beast", "godzilla"}
	movieColumnsWithDefault    = []string{"uuid", "rated", "released", "plot", "country", "language", "box_office", "production", "created_datetime", "imdb_id", "wallpaper_fu", "runtime_minutes"}
	moviePrimaryKeyColumns     = []string{"uuid"}
	movieGeneratedColumns      = []string{}
)

type (
	// MovieSlice is an alias for a slice of pointers to Movie.
	// This should almost always be used instead of []Movie.
	MovieSlice []*Movie

	movieQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	movieType                 = reflect.TypeOf(&Movie{})
	movieMapping              = queries.MakeStructMapping(movieType)
	moviePrimaryKeyMapping, _ = queries.BindMapping(movieType, movieMapping, moviePrimaryKeyColumns)
	movieInsertCacheMut       sync.RWMutex
	movieInsertCache          = make(map[string]insertCache)
	movieUpdateCacheMut       sync.RWMutex
	movieUpdateCache          = make(map[string]updateCache)
	movieUpsertCacheMut       sync.RWMutex
	movieUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single movie record from the query.
func (q movieQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Movie, error) {
	o := &Movie{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for movie")
	}

	return o, nil
}

// All returns all Movie records from the query.
func (q movieQuery) All(ctx context.Context, exec boil.ContextExecutor) (MovieSlice, error) {
	var o []*Movie

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Movie slice")
	}

	return o, nil
}

// Count returns the count of all Movie records in the query.
func (q movieQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count movie rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q movieQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if movie exists")
	}

	return count > 0, nil
}

// MovieActors retrieves all the movie_actor's MovieActors with an executor.
func (o *Movie) MovieActors(mods ...qm.QueryMod) movieActorQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"movie_actor\".\"movie_uuid\"=?", o.UUID),
	)

	return MovieActors(queryMods...)
}

// MovieDirectors retrieves all the movie_director's MovieDirectors with an executor.
func (o *Movie) MovieDirectors(mods ...qm.QueryMod) movieDirectorQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"movie_director\".\"movie_uuid\"=?", o.UUID),
	)

	return MovieDirectors(queryMods...)
}

// MovieGenres retrieves all the movie_genre's MovieGenres with an executor.
func (o *Movie) MovieGenres(mods ...qm.QueryMod) movieGenreQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"movie_genre\".\"movie_uuid\"=?", o.UUID),
	)

	return MovieGenres(queryMods...)
}

// MovieRatings retrieves all the movie_rating's MovieRatings with an executor.
func (o *Movie) MovieRatings(mods ...qm.QueryMod) movieRatingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"movie_rating\".\"movie_uuid\"=?", o.UUID),
	)

	return MovieRatings(queryMods...)
}

// MovieWatches retrieves all the movie_watch's MovieWatches with an executor.
func (o *Movie) MovieWatches(mods ...qm.QueryMod) movieWatchQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"movie_watch\".\"movie_uuid\"=?", o.UUID),
	)

	return MovieWatches(queryMods...)
}

// MovieWriters retrieves all the movie_writer's MovieWriters with an executor.
func (o *Movie) MovieWriters(mods ...qm.QueryMod) movieWriterQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"movie_writer\".\"movie_uuid\"=?", o.UUID),
	)

	return MovieWriters(queryMods...)
}

// LoadMovieActors allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (movieL) LoadMovieActors(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMovie interface{}, mods queries.Applicator) error {
	var slice []*Movie
	var object *Movie

	if singular {
		var ok bool
		object, ok = maybeMovie.(*Movie)
		if !ok {
			object = new(Movie)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMovie))
			}
		}
	} else {
		s, ok := maybeMovie.(*[]*Movie)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMovie))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &movieR{}
		}
		args = append(args, object.UUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &movieR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.UUID) {
					continue Outer
				}
			}

			args = append(args, obj.UUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`movie_actor`),
		qm.WhereIn(`movie_actor.movie_uuid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load movie_actor")
	}

	var resultSlice []*MovieActor
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice movie_actor")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on movie_actor")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for movie_actor")
	}

	if singular {
		object.R.MovieActors = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &movieActorR{}
			}
			foreign.R.Movie = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.UUID, foreign.MovieUUID) {
				local.R.MovieActors = append(local.R.MovieActors, foreign)
				if foreign.R == nil {
					foreign.R = &movieActorR{}
				}
				foreign.R.Movie = local
				break
			}
		}
	}

	return nil
}

// LoadMovieDirectors allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (movieL) LoadMovieDirectors(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMovie interface{}, mods queries.Applicator) error {
	var slice []*Movie
	var object *Movie

	if singular {
		var ok bool
		object, ok = maybeMovie.(*Movie)
		if !ok {
			object = new(Movie)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMovie))
			}
		}
	} else {
		s, ok := maybeMovie.(*[]*Movie)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMovie))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &movieR{}
		}
		args = append(args, object.UUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &movieR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.UUID) {
					continue Outer
				}
			}

			args = append(args, obj.UUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`movie_director`),
		qm.WhereIn(`movie_director.movie_uuid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load movie_director")
	}

	var resultSlice []*MovieDirector
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice movie_director")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on movie_director")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for movie_director")
	}

	if singular {
		object.R.MovieDirectors = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &movieDirectorR{}
			}
			foreign.R.Movie = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.UUID, foreign.MovieUUID) {
				local.R.MovieDirectors = append(local.R.MovieDirectors, foreign)
				if foreign.R == nil {
					foreign.R = &movieDirectorR{}
				}
				foreign.R.Movie = local
				break
			}
		}
	}

	return nil
}

// LoadMovieGenres allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (movieL) LoadMovieGenres(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMovie interface{}, mods queries.Applicator) error {
	var slice []*Movie
	var object *Movie

	if singular {
		var ok bool
		object, ok = maybeMovie.(*Movie)
		if !ok {
			object = new(Movie)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMovie))
			}
		}
	} else {
		s, ok := maybeMovie.(*[]*Movie)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMovie))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &movieR{}
		}
		args = append(args, object.UUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &movieR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.UUID) {
					continue Outer
				}
			}

			args = append(args, obj.UUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`movie_genre`),
		qm.WhereIn(`movie_genre.movie_uuid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load movie_genre")
	}

	var resultSlice []*MovieGenre
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice movie_genre")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on movie_genre")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for movie_genre")
	}

	if singular {
		object.R.MovieGenres = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &movieGenreR{}
			}
			foreign.R.Movie = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.UUID, foreign.MovieUUID) {
				local.R.MovieGenres = append(local.R.MovieGenres, foreign)
				if foreign.R == nil {
					foreign.R = &movieGenreR{}
				}
				foreign.R.Movie = local
				break
			}
		}
	}

	return nil
}

// LoadMovieRatings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (movieL) LoadMovieRatings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMovie interface{}, mods queries.Applicator) error {
	var slice []*Movie
	var object *Movie

	if singular {
		var ok bool
		object, ok = maybeMovie.(*Movie)
		if !ok {
			object = new(Movie)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMovie))
			}
		}
	} else {
		s, ok := maybeMovie.(*[]*Movie)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMovie))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &movieR{}
		}
		args = append(args, object.UUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &movieR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.UUID) {
					continue Outer
				}
			}

			args = append(args, obj.UUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`movie_rating`),
		qm.WhereIn(`movie_rating.movie_uuid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load movie_rating")
	}

	var resultSlice []*MovieRating
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice movie_rating")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on movie_rating")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for movie_rating")
	}

	if singular {
		object.R.MovieRatings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &movieRatingR{}
			}
			foreign.R.Movie = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.UUID, foreign.MovieUUID) {
				local.R.MovieRatings = append(local.R.MovieRatings, foreign)
				if foreign.R == nil {
					foreign.R = &movieRatingR{}
				}
				foreign.R.Movie = local
				break
			}
		}
	}

	return nil
}

// LoadMovieWatches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (movieL) LoadMovieWatches(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMovie interface{}, mods queries.Applicator) error {
	var slice []*Movie
	var object *Movie

	if singular {
		var ok bool
		object, ok = maybeMovie.(*Movie)
		if !ok {
			object = new(Movie)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMovie))
			}
		}
	} else {
		s, ok := maybeMovie.(*[]*Movie)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMovie))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &movieR{}
		}
		args = append(args, object.UUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &movieR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.UUID) {
					continue Outer
				}
			}

			args = append(args, obj.UUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`movie_watch`),
		qm.WhereIn(`movie_watch.movie_uuid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load movie_watch")
	}

	var resultSlice []*MovieWatch
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice movie_watch")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on movie_watch")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for movie_watch")
	}

	if singular {
		object.R.MovieWatches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &movieWatchR{}
			}
			foreign.R.Movie = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.UUID, foreign.MovieUUID) {
				local.R.MovieWatches = append(local.R.MovieWatches, foreign)
				if foreign.R == nil {
					foreign.R = &movieWatchR{}
				}
				foreign.R.Movie = local
				break
			}
		}
	}

	return nil
}

// LoadMovieWriters allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (movieL) LoadMovieWriters(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMovie interface{}, mods queries.Applicator) error {
	var slice []*Movie
	var object *Movie

	if singular {
		var ok bool
		object, ok = maybeMovie.(*Movie)
		if !ok {
			object = new(Movie)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMovie))
			}
		}
	} else {
		s, ok := maybeMovie.(*[]*Movie)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMovie)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMovie))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &movieR{}
		}
		args = append(args, object.UUID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &movieR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.UUID) {
					continue Outer
				}
			}

			args = append(args, obj.UUID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`movie_writer`),
		qm.WhereIn(`movie_writer.movie_uuid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load movie_writer")
	}

	var resultSlice []*MovieWriter
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice movie_writer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on movie_writer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for movie_writer")
	}

	if singular {
		object.R.MovieWriters = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &movieWriterR{}
			}
			foreign.R.Movie = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.UUID, foreign.MovieUUID) {
				local.R.MovieWriters = append(local.R.MovieWriters, foreign)
				if foreign.R == nil {
					foreign.R = &movieWriterR{}
				}
				foreign.R.Movie = local
				break
			}
		}
	}

	return nil
}

// AddMovieActors adds the given related objects to the existing relationships
// of the movie, optionally inserting them as new records.
// Appends related to o.R.MovieActors.
// Sets related.R.Movie appropriately.
func (o *Movie) AddMovieActors(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieActor) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MovieUUID, o.UUID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"movie_actor\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"movie_uuid"}),
				strmangle.WhereClause("\"", "\"", 0, movieActorPrimaryKeyColumns),
			)
			values := []interface{}{o.UUID, rel.UUID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MovieUUID, o.UUID)
		}
	}

	if o.R == nil {
		o.R = &movieR{
			MovieActors: related,
		}
	} else {
		o.R.MovieActors = append(o.R.MovieActors, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &movieActorR{
				Movie: o,
			}
		} else {
			rel.R.Movie = o
		}
	}
	return nil
}

// SetMovieActors removes all previously related items of the
// movie replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Movie's MovieActors accordingly.
// Replaces o.R.MovieActors with related.
// Sets related.R.Movie's MovieActors accordingly.
func (o *Movie) SetMovieActors(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieActor) error {
	query := "update \"movie_actor\" set \"movie_uuid\" = null where \"movie_uuid\" = ?"
	values := []interface{}{o.UUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MovieActors {
			queries.SetScanner(&rel.MovieUUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Movie = nil
		}
		o.R.MovieActors = nil
	}

	return o.AddMovieActors(ctx, exec, insert, related...)
}

// RemoveMovieActors relationships from objects passed in.
// Removes related items from R.MovieActors (uses pointer comparison, removal does not keep order)
// Sets related.R.Movie.
func (o *Movie) RemoveMovieActors(ctx context.Context, exec boil.ContextExecutor, related ...*MovieActor) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MovieUUID, nil)
		if rel.R != nil {
			rel.R.Movie = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("movie_uuid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MovieActors {
			if rel != ri {
				continue
			}

			ln := len(o.R.MovieActors)
			if ln > 1 && i < ln-1 {
				o.R.MovieActors[i] = o.R.MovieActors[ln-1]
			}
			o.R.MovieActors = o.R.MovieActors[:ln-1]
			break
		}
	}

	return nil
}

// AddMovieDirectors adds the given related objects to the existing relationships
// of the movie, optionally inserting them as new records.
// Appends related to o.R.MovieDirectors.
// Sets related.R.Movie appropriately.
func (o *Movie) AddMovieDirectors(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieDirector) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MovieUUID, o.UUID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"movie_director\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"movie_uuid"}),
				strmangle.WhereClause("\"", "\"", 0, movieDirectorPrimaryKeyColumns),
			)
			values := []interface{}{o.UUID, rel.UUID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MovieUUID, o.UUID)
		}
	}

	if o.R == nil {
		o.R = &movieR{
			MovieDirectors: related,
		}
	} else {
		o.R.MovieDirectors = append(o.R.MovieDirectors, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &movieDirectorR{
				Movie: o,
			}
		} else {
			rel.R.Movie = o
		}
	}
	return nil
}

// SetMovieDirectors removes all previously related items of the
// movie replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Movie's MovieDirectors accordingly.
// Replaces o.R.MovieDirectors with related.
// Sets related.R.Movie's MovieDirectors accordingly.
func (o *Movie) SetMovieDirectors(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieDirector) error {
	query := "update \"movie_director\" set \"movie_uuid\" = null where \"movie_uuid\" = ?"
	values := []interface{}{o.UUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MovieDirectors {
			queries.SetScanner(&rel.MovieUUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Movie = nil
		}
		o.R.MovieDirectors = nil
	}

	return o.AddMovieDirectors(ctx, exec, insert, related...)
}

// RemoveMovieDirectors relationships from objects passed in.
// Removes related items from R.MovieDirectors (uses pointer comparison, removal does not keep order)
// Sets related.R.Movie.
func (o *Movie) RemoveMovieDirectors(ctx context.Context, exec boil.ContextExecutor, related ...*MovieDirector) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MovieUUID, nil)
		if rel.R != nil {
			rel.R.Movie = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("movie_uuid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MovieDirectors {
			if rel != ri {
				continue
			}

			ln := len(o.R.MovieDirectors)
			if ln > 1 && i < ln-1 {
				o.R.MovieDirectors[i] = o.R.MovieDirectors[ln-1]
			}
			o.R.MovieDirectors = o.R.MovieDirectors[:ln-1]
			break
		}
	}

	return nil
}

// AddMovieGenres adds the given related objects to the existing relationships
// of the movie, optionally inserting them as new records.
// Appends related to o.R.MovieGenres.
// Sets related.R.Movie appropriately.
func (o *Movie) AddMovieGenres(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieGenre) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MovieUUID, o.UUID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"movie_genre\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"movie_uuid"}),
				strmangle.WhereClause("\"", "\"", 0, movieGenrePrimaryKeyColumns),
			)
			values := []interface{}{o.UUID, rel.UUID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MovieUUID, o.UUID)
		}
	}

	if o.R == nil {
		o.R = &movieR{
			MovieGenres: related,
		}
	} else {
		o.R.MovieGenres = append(o.R.MovieGenres, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &movieGenreR{
				Movie: o,
			}
		} else {
			rel.R.Movie = o
		}
	}
	return nil
}

// SetMovieGenres removes all previously related items of the
// movie replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Movie's MovieGenres accordingly.
// Replaces o.R.MovieGenres with related.
// Sets related.R.Movie's MovieGenres accordingly.
func (o *Movie) SetMovieGenres(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieGenre) error {
	query := "update \"movie_genre\" set \"movie_uuid\" = null where \"movie_uuid\" = ?"
	values := []interface{}{o.UUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MovieGenres {
			queries.SetScanner(&rel.MovieUUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Movie = nil
		}
		o.R.MovieGenres = nil
	}

	return o.AddMovieGenres(ctx, exec, insert, related...)
}

// RemoveMovieGenres relationships from objects passed in.
// Removes related items from R.MovieGenres (uses pointer comparison, removal does not keep order)
// Sets related.R.Movie.
func (o *Movie) RemoveMovieGenres(ctx context.Context, exec boil.ContextExecutor, related ...*MovieGenre) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MovieUUID, nil)
		if rel.R != nil {
			rel.R.Movie = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("movie_uuid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MovieGenres {
			if rel != ri {
				continue
			}

			ln := len(o.R.MovieGenres)
			if ln > 1 && i < ln-1 {
				o.R.MovieGenres[i] = o.R.MovieGenres[ln-1]
			}
			o.R.MovieGenres = o.R.MovieGenres[:ln-1]
			break
		}
	}

	return nil
}

// AddMovieRatings adds the given related objects to the existing relationships
// of the movie, optionally inserting them as new records.
// Appends related to o.R.MovieRatings.
// Sets related.R.Movie appropriately.
func (o *Movie) AddMovieRatings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieRating) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MovieUUID, o.UUID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"movie_rating\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"movie_uuid"}),
				strmangle.WhereClause("\"", "\"", 0, movieRatingPrimaryKeyColumns),
			)
			values := []interface{}{o.UUID, rel.UUID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MovieUUID, o.UUID)
		}
	}

	if o.R == nil {
		o.R = &movieR{
			MovieRatings: related,
		}
	} else {
		o.R.MovieRatings = append(o.R.MovieRatings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &movieRatingR{
				Movie: o,
			}
		} else {
			rel.R.Movie = o
		}
	}
	return nil
}

// SetMovieRatings removes all previously related items of the
// movie replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Movie's MovieRatings accordingly.
// Replaces o.R.MovieRatings with related.
// Sets related.R.Movie's MovieRatings accordingly.
func (o *Movie) SetMovieRatings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieRating) error {
	query := "update \"movie_rating\" set \"movie_uuid\" = null where \"movie_uuid\" = ?"
	values := []interface{}{o.UUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MovieRatings {
			queries.SetScanner(&rel.MovieUUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Movie = nil
		}
		o.R.MovieRatings = nil
	}

	return o.AddMovieRatings(ctx, exec, insert, related...)
}

// RemoveMovieRatings relationships from objects passed in.
// Removes related items from R.MovieRatings (uses pointer comparison, removal does not keep order)
// Sets related.R.Movie.
func (o *Movie) RemoveMovieRatings(ctx context.Context, exec boil.ContextExecutor, related ...*MovieRating) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MovieUUID, nil)
		if rel.R != nil {
			rel.R.Movie = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("movie_uuid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MovieRatings {
			if rel != ri {
				continue
			}

			ln := len(o.R.MovieRatings)
			if ln > 1 && i < ln-1 {
				o.R.MovieRatings[i] = o.R.MovieRatings[ln-1]
			}
			o.R.MovieRatings = o.R.MovieRatings[:ln-1]
			break
		}
	}

	return nil
}

// AddMovieWatches adds the given related objects to the existing relationships
// of the movie, optionally inserting them as new records.
// Appends related to o.R.MovieWatches.
// Sets related.R.Movie appropriately.
func (o *Movie) AddMovieWatches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieWatch) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MovieUUID, o.UUID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"movie_watch\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"movie_uuid"}),
				strmangle.WhereClause("\"", "\"", 0, movieWatchPrimaryKeyColumns),
			)
			values := []interface{}{o.UUID, rel.UUID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MovieUUID, o.UUID)
		}
	}

	if o.R == nil {
		o.R = &movieR{
			MovieWatches: related,
		}
	} else {
		o.R.MovieWatches = append(o.R.MovieWatches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &movieWatchR{
				Movie: o,
			}
		} else {
			rel.R.Movie = o
		}
	}
	return nil
}

// SetMovieWatches removes all previously related items of the
// movie replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Movie's MovieWatches accordingly.
// Replaces o.R.MovieWatches with related.
// Sets related.R.Movie's MovieWatches accordingly.
func (o *Movie) SetMovieWatches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieWatch) error {
	query := "update \"movie_watch\" set \"movie_uuid\" = null where \"movie_uuid\" = ?"
	values := []interface{}{o.UUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MovieWatches {
			queries.SetScanner(&rel.MovieUUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Movie = nil
		}
		o.R.MovieWatches = nil
	}

	return o.AddMovieWatches(ctx, exec, insert, related...)
}

// RemoveMovieWatches relationships from objects passed in.
// Removes related items from R.MovieWatches (uses pointer comparison, removal does not keep order)
// Sets related.R.Movie.
func (o *Movie) RemoveMovieWatches(ctx context.Context, exec boil.ContextExecutor, related ...*MovieWatch) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MovieUUID, nil)
		if rel.R != nil {
			rel.R.Movie = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("movie_uuid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MovieWatches {
			if rel != ri {
				continue
			}

			ln := len(o.R.MovieWatches)
			if ln > 1 && i < ln-1 {
				o.R.MovieWatches[i] = o.R.MovieWatches[ln-1]
			}
			o.R.MovieWatches = o.R.MovieWatches[:ln-1]
			break
		}
	}

	return nil
}

// AddMovieWriters adds the given related objects to the existing relationships
// of the movie, optionally inserting them as new records.
// Appends related to o.R.MovieWriters.
// Sets related.R.Movie appropriately.
func (o *Movie) AddMovieWriters(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieWriter) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MovieUUID, o.UUID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"movie_writer\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"movie_uuid"}),
				strmangle.WhereClause("\"", "\"", 0, movieWriterPrimaryKeyColumns),
			)
			values := []interface{}{o.UUID, rel.UUID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MovieUUID, o.UUID)
		}
	}

	if o.R == nil {
		o.R = &movieR{
			MovieWriters: related,
		}
	} else {
		o.R.MovieWriters = append(o.R.MovieWriters, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &movieWriterR{
				Movie: o,
			}
		} else {
			rel.R.Movie = o
		}
	}
	return nil
}

// SetMovieWriters removes all previously related items of the
// movie replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Movie's MovieWriters accordingly.
// Replaces o.R.MovieWriters with related.
// Sets related.R.Movie's MovieWriters accordingly.
func (o *Movie) SetMovieWriters(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MovieWriter) error {
	query := "update \"movie_writer\" set \"movie_uuid\" = null where \"movie_uuid\" = ?"
	values := []interface{}{o.UUID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MovieWriters {
			queries.SetScanner(&rel.MovieUUID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Movie = nil
		}
		o.R.MovieWriters = nil
	}

	return o.AddMovieWriters(ctx, exec, insert, related...)
}

// RemoveMovieWriters relationships from objects passed in.
// Removes related items from R.MovieWriters (uses pointer comparison, removal does not keep order)
// Sets related.R.Movie.
func (o *Movie) RemoveMovieWriters(ctx context.Context, exec boil.ContextExecutor, related ...*MovieWriter) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MovieUUID, nil)
		if rel.R != nil {
			rel.R.Movie = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("movie_uuid")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MovieWriters {
			if rel != ri {
				continue
			}

			ln := len(o.R.MovieWriters)
			if ln > 1 && i < ln-1 {
				o.R.MovieWriters[i] = o.R.MovieWriters[ln-1]
			}
			o.R.MovieWriters = o.R.MovieWriters[:ln-1]
			break
		}
	}

	return nil
}

// Movies retrieves all the records using an executor.
func Movies(mods ...qm.QueryMod) movieQuery {
	mods = append(mods, qm.From("\"movie\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"movie\".*"})
	}

	return movieQuery{q}
}

// FindMovie retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindMovie(ctx context.Context, exec boil.ContextExecutor, uUID null.String, selectCols ...string) (*Movie, error) {
	movieObj := &Movie{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"movie\" where \"uuid\"=?", sel,
	)

	q := queries.Raw(query, uUID)

	err := q.Bind(ctx, exec, movieObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from movie")
	}

	return movieObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Movie) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no movie provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(movieColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	movieInsertCacheMut.RLock()
	cache, cached := movieInsertCache[key]
	movieInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			movieAllColumns,
			movieColumnsWithDefault,
			movieColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(movieType, movieMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(movieType, movieMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"movie\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"movie\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into movie")
	}

	if !cached {
		movieInsertCacheMut.Lock()
		movieInsertCache[key] = cache
		movieInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Movie.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Movie) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	movieUpdateCacheMut.RLock()
	cache, cached := movieUpdateCache[key]
	movieUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			movieAllColumns,
			moviePrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update movie, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"movie\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, wl),
			strmangle.WhereClause("\"", "\"", 0, moviePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(movieType, movieMapping, append(wl, moviePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update movie row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for movie")
	}

	if !cached {
		movieUpdateCacheMut.Lock()
		movieUpdateCache[key] = cache
		movieUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q movieQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for movie")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for movie")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o MovieSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), moviePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"movie\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, moviePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in movie slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all movie")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Movie) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no movie provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(movieColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	movieUpsertCacheMut.RLock()
	cache, cached := movieUpsertCache[key]
	movieUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			movieAllColumns,
			movieColumnsWithDefault,
			movieColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			movieAllColumns,
			moviePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert movie, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(moviePrimaryKeyColumns))
			copy(conflict, moviePrimaryKeyColumns)
		}
		cache.query = buildUpsertQuerySQLite(dialect, "\"movie\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(movieType, movieMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(movieType, movieMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert movie")
	}

	if !cached {
		movieUpsertCacheMut.Lock()
		movieUpsertCache[key] = cache
		movieUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Movie record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Movie) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Movie provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), moviePrimaryKeyMapping)
	sql := "DELETE FROM \"movie\" WHERE \"uuid\"=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from movie")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for movie")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q movieQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no movieQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from movie")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for movie")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o MovieSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), moviePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"movie\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, moviePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from movie slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for movie")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Movie) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindMovie(ctx, exec, o.UUID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MovieSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := MovieSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), moviePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"movie\".* FROM \"movie\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, moviePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in MovieSlice")
	}

	*o = slice

	return nil
}

// MovieExists checks if the Movie row exists.
func MovieExists(ctx context.Context, exec boil.ContextExecutor, uUID null.String) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"movie\" where \"uuid\"=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, uUID)
	}
	row := exec.QueryRowContext(ctx, sql, uUID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if movie exists")
	}

	return exists, nil
}
